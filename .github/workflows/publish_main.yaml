name: Publish

on:
  push:
    branches: main
    paths: 'VERSION'
  workflow_dispatch:

jobs:
  _test:
    uses: ./.github/workflows/test.yaml

  publish:
    needs: [_test]
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - run: echo "version=$(cat VERSION)" >> "$GITHUB_OUTPUT"
        id: version
      - uses: actions/download-artifact@v4
        with:
          name: package.deb
      - uses: actions/create-release@v1
        id: create_release
        env:
          GITHUB_TOKEN: ${{ secrets.ACTIONS_GITHUB_TOKEN }}
        with:
          tag_name: v${{ steps.version.outputs.version }}
          release_name: Release v${{ steps.version.outputs.version }}
          draft: false
          prerelease: false
      - uses: actions/upload-release-asset@v1
        id: upload-release-asset
        env:
          GITHUB_TOKEN: ${{ secrets.ACTIONS_GITHUB_TOKEN }}
        with:
          upload_url: ${{ steps.create_release.outputs.upload_url }}
          asset_path: ./package.deb
          asset_name: opentelemetry-shell_${{ steps.version.outputs.version }}.deb
          asset_content_type: application/octet-stream

  demo-prepare:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.demos.outputs.matrix }}
    steps:
      - uses: actions/checkout@v4
      - run: |
          cd demos && echo */ | tr ' ' '\n' | tr -d / | jq -nR '{"include": [inputs | select(length > 0) | {demo_directory: .}]}' | tr -d '\n' | xargs -0 -I {} echo 'matrix={}' >> "$GITHUB_OUTPUT"
        id: demos

  demo-generate:
    needs: [ demo-prepare, publish ]
    runs-on: ubuntu-latest
    strategy: 
      matrix: ${{ fromJSON(needs.demo-prepare.outputs.matrix) }}
    steps:
      - uses: actions/download-artifact@v4
        with:
          name: package.deb
      - run: sudo apt-get update && sudo apt-get install -y ./package.deb && rm ./package.deb
      - uses: actions/checkout@v4
      - id: demo
        run: |
          set +o pipefail
          cd demos/${{ matrix.demo_directory }}
          otlp="$(mktemp)"
          stdout="$(mktemp)"
          stderr="$(mktemp)"
          echo "
          receivers:
            otlp:
              protocols:
                grpc:
                  endpoint: 0.0.0.0:4317
                http:
                  endpoint: 0.0.0.0:4318
          processors:
            batch:
          exporters:
            file:
              path: /etc/otelcol/otlp.json
          service:
            pipelines:
              traces:
                receivers: [otlp]
                exporters: [file]
                processors: [batch]
          " > config.yaml
          rm otlp.json || true
          touch otlp.json && chmod 0666 otlp.json
          sudo docker create --rm --mount type=bind,source=$(pwd)/config.yaml,target=/etc/otelcol/config.yaml --mount type=bind,source=$(pwd)/otlp.json,target=/etc/otelcol/otlp.json --network=host --name=collector otel/opentelemetry-collector:latest
          sudo docker start collector
          sleep 10
          cat meta.json | jq -r .setup | (grep -v '^null$' || true) | sh
          bash -e demo.sh 1> output.stdout 2> output.stderr || true
          sleep 15
          sudo docker stop collector
          rm config.yaml
      - env:
          GITHUB_TOKEN: ${{ secrets.ACTIONS_GITHUB_TOKEN }}
        run: |
          set +o pipefail
          cd demos/${{ matrix.demo_directory }}

          spans() {
            jq '.resourceSpans.[].scopeSpans.[].spans.[]' < otlp.json
          }

          convert_span_id_to_name() {
            spans | jq -r '. | select(.spanId == "'"$1"'") | .name'
          }

          get_root_span_id() {
            spans | jq -r '. | select(.name != null) | select(.parentSpanId == "") | .spanId'
          }

          get_child_span_ids() {
            spans | jq -r '. | select(.name != null) | select(.parentSpanId == "'"$1"'") | .spanId'
          }

          print_span_name_tree() {
            local span_id="$1"
            local indent="$2"
            printf '%s' "$indent"; convert_span_id_to_name "$span_id"
            get_child_span_ids "$span_id" | while read -r child_span_id; do
              print_span_name_tree "$child_span_id" "$indent  "
            done
          }

          pretty_print_attributes() {
            attributes="$(jq .[] 2> /dev/null)"
            if [ -z "$attributes" ]; then echo "{}"; return 0; fi
            printf '%s' "$attributes" | jq -r .key | while read -r key; do
              value="$(printf '%s' "$attributes" | jq 'select(.key == "'"$key"'")' | jq .value)"
              if printf '%s' "$value" | grep -q arrayValue; then
                if printf '%s' "$value" | grep -q stringValue; then
                  value="$(printf '%s' "$value" | jq .arrayValue.values.[].stringValue | tr '\n' ',')"
                elif printf '%s' "$value" | grep -q intValue; then
                  value="$(printf '%s', "$value" | jq -r .arrayValue.values.[].intValue | tr '\n' ',')"
                else
                  value=","
                fi
                value="[${value::-1}]"
              elif printf '%s' "$value" | grep -q stringValue; then
                value="$(printf '%s' "$value" | jq .stringValue)"
              elif printf '%s' "$value" | grep -q intValue; then
                value="$(printf '%s' "$value" | jq -r .intValue)"
              else
                value=null
              fi
              jq -n --argjson "$key" "$value" '$ARGS.named'
            done | jq -s add
          }

          pretty_print_events() {
            events="$(cat)"
            if [ -z "$events" ] || [ "$events" = null ]; then echo "[]"; return 0; fi
            printf '%s' "$events" | jq .[].name | wc -l | xargs seq 1 | while read -r index; do echo "$((index-1))"; done | while read -r index; do
              event="$(printf '%s' "$events" | jq ".[$index]")"
              jq -n \
                --argjson name "$(printf '%s' "$event" | jq .name)" \
                --argjson time "$(printf '%s' "$event" | jq -r .timeUnixNano)" \
                --argjson attributes "$(printf '%s' "$event" | jq .attributes | pretty_print_attributes)" \
                 '$ARGS.named'
            done | jq -s .
          }

          pretty_print_links() {
            links="$(cat)"
            if [ -z "$links" ] || [ "$links" = null ]; then echo "[]"; return 0; fi
            printf '%s' "$links" | jq .[].traceId | wc -l | xargs seq 1 | while read -r index; do echo "$((index-1))"; done | while read -r index; do
              link="$(printf '%s' "$links" | jq ".[$index]")"
              jq -n \
                --argjson trace_id "$(printf '%s' "$link" | jq .traceId)" \
                --argjson span_id "$(printf '%s' "$link" | jq .spanId)" \
                --argjson attributes "$(printf '%s' "$link" | jq .attributes | pretty_print_attributes)" \
                 '$ARGS.named'
            done | jq -s .
          }

          pretty_print_trace() {
            cat otlp.json | jq -r '.resourceSpans.[].scopeSpans.[].spans.[].spanId' | while read -r span_id; do
              span="$(jq '.resourceSpans.[].scopeSpans.[].spans.[] | select(.spanId == "'$span_id'")' < otlp.json)"
              resource_attributes="$(jq '.resourceSpans.[] | select(.scopeSpans.[].spans.[].spanId == "'$span_id'")' < otlp.json | jq .resource.attributes)"
              jq -n \
                --argjson trace_id "$(printf '%s' "$span" | jq .traceId)" \
                --argjson span_id "$(printf '%s' "$span" | jq .spanId)" \
                --argjson parent_span_id "$(printf '%s' "$span" | jq .parentSpanId)" \
                --argjson name "$(printf '%s' "$span" | jq .name)" \
                --argjson kind "$(printf '%s' "$span" | jq .kind)" \
                --argjson status "$(printf '%s' "$span" | jq .status.statusCode)" \
                --argjson time_start "$(printf '%s' "$span" | jq .startTimeUnixNano)" \
                --argjson time_end "$(printf '%s' "$span" | jq .endTimeUnixNano)" \
                --argjson attributes "$(printf '%s' "$span" | jq .attributes | pretty_print_attributes)" \
                --argjson resource_attributes "$(printf '%s' "$resource_attributes" | pretty_print_attributes)" \
                --argjson links "$(printf '%s' "$span" | jq .links | pretty_print_links)" \
                --argjson events "$(printf '%s' "$span" | jq .events | pretty_print_events)" \
                '$ARGS.named'
            done \
              | jq 'with_entries(if .key == "kind" and .value == 1 then .value = "INTERNAL" else . end)' \
              | jq 'with_entries(if .key == "kind" and .value == 2 then .value = "CLIENT" else . end)' \
              | jq 'with_entries(if .key == "kind" and .value == 3 then .value = "SERVER" else . end)' \
              | jq 'with_entries(if .key == "kind" and .value == 4 then .value = "PRODUCER" else . end)' \
              | jq 'with_entries(if .key == "kind" and .value == 5 then .value = "CONSUMER" else . end)' \
              | jq .
          }

          {
            echo '# Demo "'"$(cat ./meta.json | jq -r .title)"'"'
            cat meta.json | jq -r .description
            echo '## Script'
            echo '```sh'
            cat demo.sh
            echo '```'
            echo '## Trace Structure Overview'
            echo '```'
            print_span_name_tree "$(get_root_span_id)" ""
            echo '```'
            echo '## Full Trace'
            echo '```'
            pretty_print_trace
            echo '```'
          } > README.md
          mv otlp.json otlp.json.minimized
          jq . < otlp.json.minimized > otlp.json
          rm otlp.json.minimized
      - run: cat demos/${{ matrix.demo_directory }}/README.md
      - run: |
          cd demos/${{ matrix.demo_directory }}
          git add --intent-to-add README.md output.stdout output.stderr otlp.json
          git diff
          git diff README.md | grep -v '^+++' | grep -v '^---' | grep -v Id | grep -v _id | grep -v .id | grep -v Time | grep -v _time | grep -v timestamp | grep -v github. | grep -v telemetry.sdk.version | grep -v process.pid | grep -v process.parent_pid | grep -q '^+' && echo dirty=true >> "$GITHUB_OUTPUT" || true
        id: diff
      - name: "Resolve Reviewers"
        if: steps.diff.outputs.dirty
        id: reviewers
        run: |
          if ! [ -f .github/renovate.json ]; then exit 0; fi
          echo "reviewers=$(cat .github/renovate.json | jq -r '.reviewers | join(",")')" >> "$GITHUB_OUTPUT"
      - name: "Open Pull Request"
        if: steps.diff.outputs.dirty
        id: open-pr
        uses: peter-evans/create-pull-request@v7
        with:
          token: ${{ secrets.ACTIONS_GITHUB_TOKEN }}
          commit-message: "Update demo"
          branch: "demos/${{ matrix.demo_directory }}"
          title: "Update Demo ${{ matrix.demo_directory }}"
          body: |
            (this PR is automatically generated)
          reviewers: ${{ steps.reviewers.outputs.reviewers }}
          delete-branch: true
      - uses: peter-evans/enable-pull-request-automerge@v3
        if: steps.open-pr.outputs.pull-request-number != null
        with:
          token: ${{ secrets.ACTIONS_GITHUB_TOKEN }}
          pull-request-number: ${{ steps.open-pr.outputs.pull-request-number }}
          merge-method: squash
